# Git教程

## 创建git本地仓库

### 方法一

​	右击点击**Git GUI Here**，然后点击**Create New Repository**来创建本地仓库

### 方法二

​	右击点击**Git Bush Here**，打开命令行，自动加入当前目录，使用命令 **git init**来创建本地仓库

### 方法三

​	使用图型可视化界面

### 📢注意

​	数据先`add`进入数据暂存区，此时会在.git文件夹下生成`index`索引文件，索引通常也被称为暂存区域，它保存着将要提交到版本库里的改动的信息，包括文件名、大小、时间戳等。之后再`commit`进入本地仓库（版本库），再使用`push`进入远端仓库（工作区），使用`clone`将远端仓库中代码回滚到本地仓库。

​	通常，在进行提交之前，我们会使用 `git add` 命令将文件添加到暂存区（staging area）中。这样，我们可以在提交之前确认我们想要提交的文件列表，并有机会修改我们的选择。只有新创建文件时才用提交暂存区，之后的修改就无需提交到暂存区了，因为已经被git托管了，感觉像指针指向它了。

`		git commit` 命令用于将暂存区中的修改提交到仓库中。当我们运行 `git commit` 命令时，Git 会将暂存区中的文件快照添加到仓库的历史记录中，并且会在 `.git` 目录中生成一个新的 commit 记录。

​	若文件左下角没有图标，则表示未被纳入版本控制，即为未跟踪状态；

​	若有图标则表示已纳入版本控制，即为跟踪状态。

​	若左下角有绿色勾表示此文件未修改，和本地版本库中文件一样，为未修改状态。

​	若左下角有红色感叹号表示此文件已修改，和本地版本库中文件不一样，为已修改状态。

​	若左下角有蓝色十字表示已暂存状态，在暂存区中。

12-15 	15：30

## 设置签名

### 形式

​	用户名、邮箱，其中邮箱并不需要和用户名一致，也不会校验。

### 命令

​	分为两种，一种是项目/仓库级别，即就对这个项目而言的签名，使用命令 `git config user.name liyonxin`和命令 `git config 																					user.email 1650945363@qq.com` ; 另一种是系统用户级别，即对登录这类操作系统的用户而言的签名，使用命令 `git config --global user.name liyonxin` 和命令`git config --globaluser.email 1650945363@qq.com` 

​	若两者都存在，则项目/仓库级别优先；若两者都没有会报错不执行。

### 💎AI给出的优缺点和选择时机

#### 分析优缺点

项目级别的签名的优点是可以为不同的项目使用不同的签名，这样可以更好地组织你的项目，同时也更容易区分不同项目的提交记录。另外，项目级别的签名还可以为每个项目设置不同的签名规则，这样可以更好地确保每个项目的提交记录都符合指定的格式。

系统级别的签名的优点在于可以为整个 Git 系统设置统一的签名，这样可以更好地维护你的 Git 仓库，同时也可以更容易地管理和维护你的提交记录。

相比而言，项目级别的签名的缺点在于它需要为每个项目都设置不同的签名，这可能会增加维护和管理的复杂度，并且可能导致签名规则混乱不堪。系统级别的签名的缺点在于它无法为不同的项目设置不同的签名

#### 两种的选择时机

在选择使用项目级别的签名还是系统级别的签名时，需要根据实际情况进行选择。如果你有**许多不同的项目**，并且希望为**每个项目都设置不同的签名**，那么使用***项目级别的签名***可能会更合适。如果你的 **Git 仓库规模较小**，并且希望为整个系统设置**统一的签名**，那么使用***系统级别***的签名可能会更好。

### 目的

​	区别不同用户的提交。

### 📢注意

​	这里的签名和登录远程库的账号密码没有关系。若设置了项目/仓库级别的签名，则设置到了当前目录下的.git目录下的config文件中去了，若设置了系统级别的签名，则会在C:/user/lxy 目录下生成一个.gitconfig的隐藏文件，其中签名就在这个文件中。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215190653317.png" alt="image-20221215190653317" style="zoom:80%;" />



​	

## 添加提交及查看状态操作



使用命令 `git status` 查看状态，若工作目录下没有文件，则依照上图所示；若有则依照下图所示。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215191056642.png" alt="image-20221215191056642" style="zoom:80%;" />

第三行提示有未追踪的文件(untracked files)，我们使用 `git add git.md` 将git.md提交至本地仓库的缓存区（./.git/index)，而缓冲区用于跟踪文件的变更，可以使用 `git ls-files --stage` 命令查看缓冲区中所有文件的信息，包括文件名、状态、指纹等信息。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215200604699.png" alt="image-20221215200604699" style="zoom: 80%;" />

再次查看git状态，提示可以使用 `git rm --cached git.md` 命令来将暂存区文件删除，删后工作区中源文件不会删除，变回上个图的状态。

使用 `git commit git.md` 进行提交至本地仓库，便会进入vim编辑器，如下图。在此模式可以输入此次做了哪些变化的信息。输入 `i` 进入编辑模式，输入信息之后按esc退出编辑模式，按 `：` 进入命令行模式，按 `wq` 保存退出，便提交成功。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215220837590.png" alt="image-20221215220837590" style="zoom:80%;" />

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215221641030.png" alt="image-20221215221641030" style="zoom:80%;" />

`master` 表示主干，`root-commit` 表示第一次提交作为根提交，第三个参数表示哈希值，用来标识每一次的提交，第四个参数就是提交信息。一个文件改变了，插入了89行。

再次查看git的状态，如下图

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215223624562.png" alt="image-20221215223624562" style="zoom:80%;" />

提交也可以使用如下不进入vim的方式进行添加消息的提交

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221215224625114.png" alt="image-20221215224625114" style="zoom:80%;" />

这次没有了根提交，1 file changed 表示发生了一次文件变更，14 insertions(+), 2 deletions(-) 分别表示发生了14次新增和2次删除。例如，假设在一次保存中，新增了5行内容，并删除了3行内容。那么新增和删除的数量都会增加，新增数量会增加5，删除数量会增加3。

### 💎AI解释新增和删除

在git中，新增和删除的数量都是指受影响的行数。在进行提交操作时，git会自动计算出文件中新增和删除的行数，并在输出中显示这些信息。例子见上面。

### 💎AI对暂存区的理解

在git中，暂存区是一个特殊的区域，用于存储文件的变更信息。它允许开发人员将文件的修改内容临时存储起来，并选择何时将它们提交到版本库中。

暂存区的作用有多种。首先，它可以帮助开发人员分离出不同的修改，方便进行管理和维护。例如，如果你正在修改一个文件，但同时又想保留原有的内容，那么你可以将新增的内容存储在暂存区中，然后再提交。这样，你就可以将新增内容和原有内容分开管理，避免混淆。

其次，暂存区可以方便开发人员进行版本控制。每次提交时，git都会将暂存区中的内容作为一个新的版本进行保存，这样就可以方便开发人员查看代码的历史变更记录，并在必要时回退到某个特定的版本。

可以使用`git restore git.md` 来将暂存区内容回滚到工作区。（自己搜到的）

## 使用命令实现版本的穿梭

使用`git log` 查看详细记录，但可能存在很多历史记录，太多可能要点空格进行翻页（空格向下翻页、b向上翻页、q退出），看起来不方便，可以使用`git log --pretty=oneline` 使得每条数据显示一行，但会省略提交日期和作者、邮箱信息，如下图所示

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221216001906835.png" alt="image-20221216001906835" style="zoom:80%;" />

### 💎AI对HEAD的解释（插入讲）

​	HEAD是Git中用来指向当前版本的指针。它是指向当前所在分支的最新提交的一个指针，如果当前分支没有提交，那么HEAD指向下一	次将要提交的位置。通常，HEAD在Git中被视为指向当前版本的快照的一个别名。而master表示主分支。

也可以使用 `git log --oneline` 简洁显示数据，但哈希值只会节选一部分；同时也可以使用 `git reflog` 来查看版本信息，其中哈希值也为节选部分，HEAD@{0}表示0步可以到达。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221216003121470.png" alt="image-20221216003121470" style="zoom:80%;" />

### 💎AI对git log 和git reflog 哈希值不同的原因解释

​	Git log和Git reflog两个命令都会列出提交的历史记录，但它们的输出内容有所不同。Git log会列出每次提交的提交信息，而Git reflog	则会列出每次提交的哈希值。

​	由于Git log只会列出提交信息，因此每次提交的哈希值不会被显示出来。而Git reflog则会将每次提交的哈希值作为输出结果之一，因	此它显示的哈希值可能与Git log中显示的哈希值不同。

​	此外，Git reflog会记录每次提交之后的HEAD的变化，因此在Git reflog的输出结果中，每次提交的哈希值可能不同于实际提交的哈希	值。

​	总之，Git log和Git reflog两个命令都会列出提交的历史记录，但它们的输出内容和所列出的哈希值可能会有所不同。

可以通过HEAD来进行指针移动实现版本的穿梭

### 三种方法进行版本的穿梭

#### 第一种使用索引值的方式

```txt
git reset --hard 部分哈希值		此方法会将之前的提交记录从历史记录中删去
```

##### 💎AI对`git reset` 三个参数的解释

`git reset` 命令有三个选项：`--soft`、`--mixed` 和 `--hard`。这三个选项决定了 `git reset` 命令的行为。

- `--soft` 选项会将当前分支的指针移动到指定的提交，但不会撤销任何更改，也不会删除这些更改的历史记录。这意味着，你可以在回滚到以前版本后继续开发，并在未来的提交中包含这些更改。

- `--mixed` 选项会将当前分支的指针移动到指定的提交，并撤销所有在这个提交之后的更改，但不会删除这些更改的历史记录。这意味着，你可以在回滚到以前版本后继续开发，但是你的更改会在新的提交中，而不是在回滚的提交之后。

- 使用 `git reset --hard` 命令会将当前分支的指针移动到指定的提交，并撤销所有在这个提交之后的更改，同时删除这些更改的历史记录。这意味着你将无法在回滚到以前版本后继续开发，因为所有在这个提交之后的更改都已被撤销并删除了历史记录。

  因此，使用 `git reset --hard` 命令需要小心，因为它会导致数据丢失。应谨慎使用，并确保你知道自己在做什么。

  **简言之** `--soft` 只会在本地库移动HEAD指针；`--mixed` 会在本地库移动HEAD指针并且会重置暂存区；`--hard` 会在本地库移动HEAD指针、会重置暂存区、还会重置工作区。

#### 第二种使用`^` 符号的方式(只能后退)

```
git reset --hard HEAD^		此方法将回退到前一个版本上去
git reset --hard HEAD^^		此方法将回退到前两个版本上去
```

#### 第三种使用`~` 符号的方式(只能后退)

```
git reset --hard HEAD~n		此方法将回退到前n个版本上去
```

若将一个文件误删而此文件之前状态已经提交本地库，但删除时状态没保存至本地库，则可以使用如下命令恢复

```txt
git reset --hard HEAD
```

若删除时状态保存至本地库，则可以使用如下命令恢复

```txt
git reset --hard 之前状态的哈希值
```

## 比较文件

使用如下命令

```txt
git diff 要比较的文件名A加上后缀(或是历史版本) (要比较的文件名B加上后缀)    若只有一个文件则是将工作区文件和暂存区文件进行比较
```

也可以是`git diff HEAD git.md` ，在这里，`HEAD` 指向的是当前的最新提交，它代表你当前所在的分支。因此，这条命令会将当前分支中最新的提交和工作区中的 `git.md` 文件进行比较。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221216172739475.png" alt="image-20221216172739475" style="zoom:80%;" />

使用 `git diff` 命令时，默认情况下会比较工作区中的文件和暂存区中的文件。

也可以使用 `git diff` 命令来比较两个提交之间的差异，例如：

```txt
git diff HEAD~1 HEAD
```

还可以使用 `git diff` 命令来比较两个分支之间的差异，例如：

```txt
git diff branch1 branch2
```

## 分支管理

一般以后开发时，要建立一个分支，一般以`feature_` 打头，例如`feature_game` ，使用`hot fix` 分支来修复bug。分支开始创建会和当前master主干保持一致。

### 分支的好处

同时并行推进多个功能开发,提高开发效率
各个分支在开发过程中，如果某一个分支开发失败,不会对其他分支有任何影响。失败的分支删除重新开始即可。

### 查看所有分支

使用命令`git branch -v` 来查看所有存在的分支，以及在每个分支上进行的最后一次提交。

该`-v`标志代表“详细”，它使 Git 显示每个分支的完整提交哈希，以及每个分支上最近提交的提交消息。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221216182809336.png" alt="image-20221216182809336" style="zoom:80%;" />

其中（`*` ）表示当前分支。

### 创建分支

使用命令如下

```txt
git branch 分支名
```

### 切换分支

使用命令如下

```txt
git checkout 分支名
```

可以使用(`tab`)键补全分支名。

### 合并分支

第一步：切换到要被和并的分支上

第二步：使用merge命令进行合并

```txt
git merge 分支名
```

## 解决合并分支后的冲突问题

若要合并的分支中的文件发生冲突，在进行合并时就会报错，需要手动合并，其中发生了一点变化，16509@DESKTOP-E66NEIJ MINGW64 /g/mygit **(分支名|MERGING)** ，表示正在处于合并状态，要合并分支的文件中产生了变化，即特殊标记。打开冲突文件

```txt
<<<<<<< HEAD			//就是指要合并的分支
本分支中冲突的部分内容，以下面的等号为界
=======
要被合并的冲突的部分内容
>>>>>>> 要被合并的分支名
```

只要自己筛选一下要用信息，之后将特殊标记删除就完成了编辑，之后退出vim，使用以下命令退出合并状态，也可以通过`git status` 获得提示

```txt
git add 冲突文件名加后缀
git commit -m "日志信息"		//注意此处不能加上冲突文件名，会产生歧义从而报错
```

## Hash算法

采用相同Hash算法和相同数据，产生的Hash相同；若采用相同Hash算法和不同数据，产生的Hash值一般不同但长度一定相同。而git采取了SHA-1算法

## Git版本数据管理机制

采用了快照（snapshot）的方式，而不是采用了每个版本保存不一样的信息最后拼接的方式。具体来讲就是若文件没有变化，就指向之前版本的指针；若发生变化则存储变化的文件。每一次提交的文件都会产生一个Hash值，从而生成一个树对象，而树对象也有自己的Hash值，提交对象包含了树对象，也有自己的一个Hash值。提交对象和它的父对象形成了一个链条，如下图

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221217000610712.png" alt="image-20221217000610712" style="zoom:80%;" />

新建一个分支，只是将这个分支指针指向当前分支的当前版本，即快照，不涉及文件的复制，效率很高。切换分支也只是改变HEAD指针的指向。

<img src="C:\Users\16509\AppData\Roaming\Typora\typora-user-images\image-20221217001710850.png" alt="image-20221217001710850" style="zoom:80%;" />

32